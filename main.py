# -*- coding: utf-8 -*-
from translater import translate
from file_scanner import scan_directory
import decorator
import file_util
import time
import sys
import json
from tqdm import tqdm


def trans(lines):
    """
    读取和翻译文件
    :param file_name: 文件名
    :return:
    """
    trans_result = ""
    # TODO 字符串是否是不可改变的？
    waiting_trans = ""
    # 状态为0说明在代码行， 状态为1 说明在注释行
    status = 0
    for line in lines:
        # TODO 改成正则匹配
        if line.lstrip().startswith('/*'):
            # 如果当前为注释首行
            trans_result += line
            waiting_trans += line
            status = 1
        elif line.rstrip().endswith('*/') and status == 1:
            # 如果当前为注释末行
            trans_result += line
            waiting_trans += line
            status = 0
        elif status == 1:
            # 如果当前处于注释文本中
            trans_result += line
            waiting_trans += line
        elif status == 0:
            # 查询翻译结果
            if len(waiting_trans) != 0:
                # 查看第一行注释开头的空格数, 因为有可能是\t制表符
                space_index = waiting_trans.index('/')
                space_content = waiting_trans[0:space_index]
                deco = decorator.before_trans(waiting_trans)
                # 添加异常处理是为了定位异常来源
                try:
                    trans_res = translate(deco)
                    # 添加翻译结果
                    trans_result += decorator.after(trans_res, space_content).encode('utf-8').decode('utf-8')
                except json.decoder.JSONDecodeError as e:
                    print("翻译内容是：")
                    print(deco)
                    raise e

            # 添加不用翻译的当前行
            trans_result += line
            # 待翻译置为空
            waiting_trans = ""
        else:
            raise SystemError("状态错误")
    return trans_result


# 使用此标题进行错误恢复
head = "/** Generated by english-annotation-buster, Powered by Google Translate.**/\n"


def i_am_buster(source_dir):
    # 错误恢复，翻译到一半挂了恢复, 直接在开头加一段注释，读文件读到该注释，直接跳过
    # TODO 文件太多，多进程翻译（貌似python多线程就是个渣渣）
    """

    :param source_dir: 项目文件夹
    :return:
    """
    files = scan_directory(source_dir)
    count = 0
    progress_iter = tqdm(files)
    for file_name in progress_iter:
        # 去除source_dir，使得显示更加舒适
        short_file_name = file_name[len(source_dir):]
        progress_iter.set_description("正在处理文件{}".format(short_file_name))
        lines = file_util.read_file(file_name)
        count += 1
        if len(lines) != 0 and lines[0].startswith(head):
            continue
        # 翻译结果加上头部，用于错误快速恢复
        trans_result = head + trans(lines)
        file_util.write_back(trans_result, file_name)
        time.sleep(10)


def print_usage():
    """
    打印使用信息
    """
    print('Usage: python main.py [path to your java source folder]')
    print('\nExamples:')
    print('\tpython main.py C:\\path\\to\\your\\java\\source\\folder')
    print('\tpython main.py /home/user/path/to/your/java/source/folder')


if __name__ == "__main__":
    # 添加对命令行的解析，如果目前用不着可以先注释它
    if len(sys.argv) < 2:
        print_usage()
        exit()
    code_path = sys.argv[1]
    i_am_buster(code_path)